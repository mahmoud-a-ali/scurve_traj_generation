#!/usr/bin/env python
''' python script to auto-generate random test-cases to test "traj.fit_traj_segment" function,
    this file rejects all the unfeasible/illogical cases that can not be fit into one segment, 
    and it accepts all the feasible cases that can be traeted as one segment, 
'''

import random 
import os
import stat
import traj 

def generate_random_test_cases(num_of_cases, p_max_abs, v_max_abs, a_max_abs, j_max_abs, fixed_limit):
    test_auto_generated_cases  = os.getcwd() +"/autogenerated_random_test_cases.py"
    plot_random_cases  = os.getcwd() +"/plot_autogenerated_random_test_cases.py"
   
    with open(test_auto_generated_cases, 'w') as random_cases:
        with open(plot_random_cases, 'w') as plot_segment:
            print >> random_cases, '''
#this is an auto-generated test file, generated using python script: generate_random_test_cases -->    
import nose
import numpy as np
import random 
import traj


def check_fit_traj_segment(p_start, p_end, v_start, v_end, p_max, v_max, a_max, j_max):
    position, velocity, acceleration, jerk = traj.fit_traj_segment(p_start, p_end, v_start, v_end, p_max, v_max, a_max, j_max)

    t_start = position.boundaries[0]
    t_end = position.boundaries[-1]
    p_start_computed = position(t_start)
    v_start_computed = velocity(t_start)
    p_end_computed = position(t_end)[0]
    v_end_computed = velocity(t_end)[0]
    
    ### test_1: test if the calculated start/end pos/vel are equal to the given ones
    assert np.isclose(p_start, p_start_computed)
    assert np.isclose(p_end, p_end_computed)    
    assert np.isclose(v_start, v_start_computed)
    assert np.isclose(v_end, v_end_computed)
    
    ### 2) test if the calculated  pos/vel/acc/jrk are within the given limits p_max, v_max, a_max, j_max at each time_instatnt the segment_phase changes 
    for phase_time in position.boundaries:
        p_computed = position(phase_time)
        v_computed = velocity(phase_time)
        a_computed = acceleration(phase_time)
        j_computed = jerk(phase_time)
        
        assert np.less_equal( abs(p_computed), p_max+1e-6) #added 1e-6 because sometime it gives fails even if the difference is less than (1e-6) 
        assert np.less_equal( abs(v_computed), v_max+1e-6)        
        assert np.less_equal( abs(a_computed), a_max+1e-6)
        assert np.less_equal( abs(j_computed), j_max+1e-6)

'''
            print >> plot_segment, '''#!/usr/bin/env python
#this is an auto-generated test file, generated using python script: generate_random_test_cases -->    
from traj import plot_traj_segment
'''
            ## assign limits if it is fixed 
            p_max = p_max_abs
            v_max = v_max_abs
            a_max = a_max_abs
            j_max = j_max_abs  
            
            
            case = 0
            while case < num_of_cases:
                
                # random limits option: fixed_limit= False
                if not fixed_limit: 
                    p_max = random.uniform(0.1, p_max_abs)
                    v_max = random.uniform(0.1, v_max_abs)
                    a_max = random.uniform(0.1, j_max_abs)
                    j_max = random.uniform(0.1, a_max_abs)
                    
               
               ## choose random start/stop pos/vel within the limits (given or random generated limits)    
                p_start = random.uniform(-p_max, p_max)
                p_end   = random.uniform(-p_max, p_max)
                v_start = random.uniform(-v_max, v_max)
                v_end   = random.uniform(-v_max, v_max)
                
                
                
                ##################### check cases when pos_diff less than the min pos_diff to reach v_end from v_start               
                if(v_start*v_end>0):
                    abs_minPos_to_vf, acc_to_vf, t_jrk_to_vf, t_acc_to_vf = traj.calculate_minPos_reachAcc_maxJrkTime_maxAccTime_to_final_vel(abs(v_start), abs(v_end), v_max, a_max, j_max)
                    if abs_minPos_to_vf > abs(p_end-p_start):
                        continue
                
                
                
                ##################### check cases when combination of: motion & pos_diff requires that position violate p_max               
                if(v_start*v_end<0):                
                    minPos_to_zero, acc_to_zero, t_jrk_to_zero, t_acc_to_zero = traj.calculate_minPos_reachAcc_maxJrkTime_maxAccTime_to_final_vel(v_start,   0.0,   v_max, a_max, j_max)
                    minPos_to_vf, acc_to_vf, t_jrk_to_vf, t_acc_to_vf         = traj.calculate_minPos_reachAcc_maxJrkTime_maxAccTime_to_final_vel(    0.0, v_end,   v_max, a_max, j_max) 
                    pos_diff = p_end - p_start
                    pos_dominant = pos_diff - minPos_to_zero - minPos_to_vf    
                
                    # A) complex positive motion case ########################
                    if pos_dominant > 0:  ## positive dominant case       
                        if v_start < 0 and v_end > 0: # from negative to positive 
                            if abs(p_start+minPos_to_zero) > p_max or abs(p_start+minPos_to_zero+minPos_to_vf) > p_max or  abs(p_start+minPos_to_zero+minPos_to_vf+pos_dominant) > p_max:
                                continue
                        elif v_start > 0 and v_end < 0: #from positive to negative
                            if abs(p_start+pos_dominant) > p_max or abs(p_start+pos_dominant+minPos_to_zero) > p_max or  abs(p_start+pos_dominant+minPos_to_zero+minPos_to_vf) > p_max:
                                continue
                            
                    # B) complex negative motion case ########################
                    if pos_dominant < 0:  ## negative dominant case 
                        if v_start < 0 and v_end > 0: # from negative to positive
                            if abs(p_start+pos_dominant) > p_max or abs(p_start+pos_dominant+minPos_to_zero) > p_max or  abs(p_start+pos_dominant+minPos_to_zero+minPos_to_vf) > p_max:
                                continue
                        elif v_start > 0 and v_end < 0: #from positive to negative
                            if abs(p_start+minPos_to_zero) > p_max or abs(p_start+minPos_to_zero+minPos_to_vf) > p_max or  abs(p_start+minPos_to_zero+minPos_to_vf+pos_dominant) > p_max:
                                continue
                
                 
                 
                ##################### check cases when motion direction is opposit pos_diff direction
                if (v_start>0 and v_end>0 and (p_end-p_start)<0):   # +ve motion vs -ve pos_diff
                    continue
                elif (v_start<0 and v_end<0 and (p_end-p_start)>0): # -ve motion vs +ve pos_diff
                    continue
                

                case +=1
                ## print the test statement for this case in the generated test script
                print>> random_cases, '''
def test_case_{}():
    check_fit_traj_segment({}, {}, {}, {},  {}, {}, {}, {})
    '''.format(case, p_start, p_end, v_start, v_end, p_max, v_max, a_max, j_max  )
    
    
                ## print the plot statement for this case in the plotting generated script
                print>> plot_segment, '''#case_{}
plot_traj_segment({}, {}, {}, {}, {}, {}, {}, {})
            '''.format( case, p_start, p_end, v_start, v_end, p_max, v_max, a_max, j_max )
    
                
                
    ## make the generated file executable            
    st = os.stat(test_auto_generated_cases)
    os.chmod(test_auto_generated_cases, st.st_mode | stat.S_IEXEC)
    st = os.stat(plot_random_cases)
    os.chmod(plot_random_cases, st.st_mode | stat.S_IEXEC)

            
            
            
   
##### generate random cases
num_of_cases = 100

## random cases with fixed limits 
p_max = 5.0
v_max = 2.0
a_max = 3.0
j_max = 1.0      

## random cases with variable limits: [the sollowing are limits for the limits]
p_max = 10.0
v_max = 10.0
a_max = 10.0
j_max = 10.0   


fixed_limit = False 
generate_random_test_cases(num_of_cases, p_max, v_max, a_max, j_max, fixed_limit)       
    
        
        
        
        